#+begin_export latex
\subsection{Introduction}
The program \texttt{ref2query} takes a \texttt{fasta} file of shared
homologous regions (an \textit{intersection}) as input, with the
coordinates of segregating sites included in the headers. This file is
generated by \texttt{intersect -s}. The program outputs either the
coordinates or sequences of the corresponding regions in a query
genome. It identifies these regions by performing an exact match of
the leftmost anchor of the homologous regions and extending the match
to the length of the homologous region. An exact matching anchor is a
prefix of the intersection that ends before the first segregating
site.

\texttt{ref2query} includes hooks for import and the main function.
#+end_export
#+begin_src go <<ref2query.go>>=
  package main
  import (
	  //<<Imports>>
  )
  //<<Data types>>
  func main() {
	  //<<Main function>>
  }
#+end_src
#+begin_export latex
\subsection{Implementation}
In the main function, we declare options, set usage, parse the
options, search for regions, and print the match coordinates, if the
\texttt{-s} flag has not been toggled (see options).
#+end_export
#+begin_src go <<Main function>>=
  //<<Declare options>>
  //<<Set usage>>
  //<<Parse the options>>
  //<<Perform the search>>
  if !*optS {
	  //<<Print match coordinates>>
  }
#+end_src
#+begin_export latex
The program accepts a \texttt{fasta}-formatted sequence as a reference
that is the output of \texttt{intersect}. The user can specify the
length of the referece's prefix to include for exact matching, set the
maximum number of threads, and allow matching short regions. As an
alternative, the user can opt using entire regions for exact
matching. Finally, the user can toggle the output format to printing
match sequences.
#+end_export
#+begin_src go <<Declare options>>=
  optR := flag.String("r", "", "reference sequence")

  optL := flag.Int("l", 15,
	  "length of a prefix anchor for matching")

  optShort := flag.Bool("short", false,
	  "allow regions not longer than l")

  optC := flag.Bool("c", false,
	  "use complete regions for exact matching")

  optS := flag.Bool("s", false, "print match sequences")

  optT := flag.Int("t", runtime.NumCPU(),
	  "maximum number of available threads")
#+end_src
#+begin_export latex
We import \texttt{flag} and \texttt{runtime}.
#+end_export
#+begin_src go <<Imports>>=
  "flag"
  "runtime"
#+end_src
#+begin_export latex
The usage consists of three statements: the actual usage statement, an
explanation of the programâ€™s purpose, and an example command.
#+end_export
#+begin_src go <<Set usage>>=
  u := "ref2query [options]... <query files>"
  p := "Find reference homologous regions " +
	  "of the intersection in queries"
  e := "ref2query -r intersection.fasta query.fasta"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We import \texttt{clio}.
#+end_export
#+begin_src go <<Imports>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
We parse the options and interpret the remaining arguments as query
file names. The set of query sequences ideally consists of at least
one of the target sequences used to calculate the intersection. Then
we check the user's input. We exit if either queries or reference are
missing. Then we access the values of \texttt{-l} and \texttt{-t}. We
exit if the values of either is zero or less to avoid a panic. We also
set the maximum number of threads.
#+end_export
#+begin_src go <<Parse the options>>=
  flag.Parse()

  queryFiles := flag.Args()

  if len(queryFiles) < 1 {
	  fmt.Fprintf(os.Stderr,
		  "please specify queries\n")
	  os.Exit(1)
  }

  if *optR == "" {
	  fmt.Fprintf(os.Stderr,
		  "please specify a reference\n")
	  os.Exit(1)
  }

  if *optL < 1 {
	  fmt.Fprintf(os.Stderr,
		  "cannot use %v as the number of matches\n",
		  *optL)
	  os.Exit(1)
  }


  if *optT < 1 {
	  fmt.Fprintf(os.Stderr,
		  "cannot use %v as the number of threads\n",
		  *optT)
	  os.Exit(1)
  }

  runtime.GOMAXPROCS(*optT)
#+end_src
#+begin_export latex
We import \texttt{fmt} and \texttt{os}.
#+end_export
#+begin_src go <<Imports>>=
  "fmt"
  "os"
#+end_src
#+begin_export latex
We create a data struct \texttt{region} to store regions found in a
query. The struct includes:

\begin{enumerate}
  \itemsep0em
  \item a header of the sequence (contig) \texttt{rh}, to which the
    region belongs in the reference;
  \item start of the region in the reference \texttt{rs};
  \item end of the region in the reference \texttt{re};
  \item a header of the sequence (contig) \texttt{qh}, to which the
    region belongs in the query;
  \item start of the region in the query \texttt{qs};
  \item end of the region in the query \texttt{qe};
  \item a strand indicator \texttt{onReverseStrand}.
\end{enumerate}

We keep the coordinates of the reference as type \texttt{strings}
because they are going to be extracted from the headers and no
calculations are performed on them within the program.
#+end_export
#+begin_src go <<Data types>>=
  type region struct {
	  rh string
	  rs string
	  re string
	  qh string
	  qs int
	  qe int
	  onReverseStrand bool
  }
#+end_src
#+begin_export latex
We read the reference and prepare it for the analysis. After that we
iterate over the query files and perform the search concurrently. For
this, we need to initialize a workgroup, a \texttt{Mutex}, and a slice
of regions to store the outputs in. Each sequence of the refrence is
processed as a \texttt{task} by the \texttt{process} function that is
to be written. Once a region is processed, we store the result in the
slice using the \texttt{Mutex}.
#+end_export
#+begin_src go <<Perform the search>>=
  //<<Read the reference file>>
  //<<Prepare the reference>>
  var regions []region
  var query []*fasta.Sequence
  for _, queryFile := range queryFiles {
	  //<<Read the query file>>
	  //<<Prepare the query>>

	  // Initialize the concurrent search
	  var wg sync.WaitGroup
	  var mu sync.Mutex

	  //<<Define the process function>>

	  // Start proceesing
	  for _, task := range reference {
		  wg.Add(1)
		  go func(t *fasta.Sequence) {
			  defer wg.Done()
			  process(t, query)
		  }(task)
	  }

	  // Wait for all workers to finish
	    wg.Wait()
  }
#+end_src
#+begin_export latex
We import \texttt{sync} and \texttt{fasta}.
#+end_export
#+begin_src go <<Imports>>=
  "sync"
  "github.com/evolbioinf/fasta"
#+end_src
#+begin_export latex
We open the reference file. If it has been opened successfully, we
read it and store sequences in a slice.
#+end_export
#+begin_src go <<Read the reference file>>=
  f, err := os.Open(*optR)
  if err != nil {
	  fmt.Fprintf(os.Stderr,
		  "couldn't open the reference %v\n", *optR)
  }
  reference := fastautils.ReadAll(f)
#+end_src
#+begin_export latex
We import \texttt{fastautils}.
#+end_export
#+begin_src go <<Imports>>=
  "github.com/ivantsers/fastautils"
#+end_src
#+begin_export latex
We convert reference's data bytes to uppercase.
#+end_export
#+begin_src go <<Prepare the reference>>=
  for _, seq := range reference {
	  fastautils.DataToUpper(seq)
  }
#+end_src
#+begin_export latex
We read all sequences of the query.
#+end_export
#+begin_src go <<Read the query file>>=
  f, err = os.Open(queryFile)
  if err != nil {
	  fmt.Fprintf(os.Stderr,
		  "couldn't open the query %v\n", queryFile)
  }
  query = fastautils.ReadAll(f)
#+end_src
#+begin_export latex
We convert bytes of the query's entries to uppercase, then append the
reverse strand to each query sequence.
#+end_export
#+begin_src go <<Prepare the query>>=
  for _, seq := range query {
	  fastautils.DataToUpper(seq)
	  fastautils.AddReverseComplement(seq)
  }
#+end_src
#+begin_export latex
The \texttt{process} takes a task, which is one sequence of the
\texttt{reference}, and the entire \texttt{query} slice. The function
checks the format of the task's header, parses a properly formatted
header and constructs a pattern for exact matching, and performs the
mathching.
#+end_export
#+begin_src go <<Define the process function>>=
  process := func(refseq *fasta.Sequence,
	  query []*fasta.Sequence) {
		  var reg region
		  goodFormat := false
		  //<<Check the sequence header formatting>>
		  if goodFormat {
			  //<<Parse the header>>
			  //<<Construct a pattern>>
			  //<<Perform the matching>>
		  }
	  }
#+end_src
#+begin_export latex
The header of an input sequence has to contain its coordinates in the
reference and positions of mutations, formatted as in the output of
\texttt{intersect -s}, for example:

\begin{verbatim}
>referenceContig1_(5..15) 3 5 10 12
\end{verbatim}

The header should have at least two fields separated with single
whitespaces: 1) a contig name, an underscore, region coordinates in
parenthesis; 2) the number of mutations. If the current sequence's
header doesn't have such a format, we notify the user and set the
\texttt{goodFormat} switch to \texttt{false}. This will make the loop
skip this sequence.
#+end_export
#+begin_src go <<Check the sequence header formatting>>=
  header := refseq.Header()
  re := regexp.MustCompile(`^[^\s]+_\(\d+\.\.\d+\) \d+.*$`)
  if re.MatchString(header) {
	  goodFormat = true
  } else {
	  fmt.Fprintf(os.Stderr,
		  "skipping the sequence '%v': " +
			  "wrong header format\n",
		  header)
  }
#+end_src
#+begin_export latex
We import \texttt{regexp}.
#+end_export
#+begin_src go <<Imports>>=
  "regexp"
#+end_src
#+begin_export latex
We parse \texttt{refseq}'s header to guide the pattern
construction. We split the header string into fields by whitespaces
and check the second filed, which is the number of mutations. Then we
extract necessary information from both parts of the header.
#+end_export
#+begin_src go <<Parse the header>>=
  headerFields := strings.Split(header, " ")
  //<<Get the coordinates of the region>>
  //<<Get the information on mutations>>
#+end_src
#+begin_export latex
We import \texttt{strings}.
#+end_export
#+begin_src go <<Imports>>=
  "strings"
#+end_src
#+begin_export latex
The information on mutations is a slice of integers, where the first
element is the number of mutations, and the following elements are
their positions (one-based). We split the field by whitespaces and
convert each sub-field into an integer.
#+end_export
#+begin_src go <<Get the information on mutations>>=
  mutationFields := headerFields[1:]
  var mutationInfo []int

  for _, f := range mutationFields {
	  num, err := strconv.Atoi(f)
	  if err != nil {
		  //<<Error of field type conversion>>
	  }
	  mutationInfo = append(mutationInfo, num)
  }
#+end_src
#+begin_export latex
We import \texttt{strconv}.
#+end_export
#+begin_src go <<Imports>>=
  "strconv"
#+end_src
#+begin_export latex
We print an error message if the conversion went wrong and exit.
#+end_export
#+begin_src go <<Error of field type conversion>>=
  fmt.Fprintf(os.Stderr, "error of parsing the number " +
	  "of mutations '%v' " +
	  "in the sequence '%v': %v\n",
	  f, header, err)
  os.Exit(1)
#+end_src
#+begin_export latex
We get the coordinates of the reference region from its header. For
this, we create a regular expression, find a substring match in the
first field of the header, and store the coordinates as two variables.
#+end_export
#+begin_src go <<Get the coordinates of the region>>=
  coordinateFields := headerFields[0]
  re := regexp.MustCompile(`\((\d+)\.\.(\d+)\)`)
  coords := re.FindStringSubmatch(coordinateFields)
  var refStart, refEnd string
  if len(coords) == 3 {
	  refStart = coords[1]
	  refEnd = coords[2]
  }
#+end_src
#+begin_export latex
If the user has opted to use complete reference regions (the flag
\texttt{-c}), we use the entire sequence as a pattern. If it's not the
case, we copy first \texttt{l} nucleotides of the reference as
specified in \texttt{optL} flag. If the reference is not longer than
that and the user allows reporting short regions, we just take
whatever we have. If short regions are not allowed, we return
early. We add wildcards for mutations to our pattern once (and if) we
have it.
#+end_export
#+begin_src go <<Construct a pattern>>=
  refseqLen := len(refseq.Data())
  var pattern []byte
  if *optC {
	  pattern = refseq.Data()
  } else if refseqLen > *optL {
	  pattern = refseq.Data()[:*optL]
  } else if *optShort {
	  pattern = refseq.Data()
  } else {
	  return
  }
  //<<Add wildcards for mutations>>
#+end_src
#+begin_export latex
Should the sequence contain no mutations, we leave everything as
is. If mutations are present, we extract their positions, convert them
to zero-based coordinates by subtracting one and replace the
corresponding bytes of the \texttt{pattern} with dots. We break from
the loop if the current mutation is out of boundaries of the pattern.
#+end_export
#+begin_src go <<Add wildcards for mutations>>=
  numMutations := mutationInfo[0]
  if numMutations > 0 {
	  posMutations := mutationInfo[1:]
	  patternLastByteIdx := len(pattern) - 1
	  for _, pos := range posMutations {
		  posZero := pos - 1
		  if posZero > patternLastByteIdx {
			  break
		  }
		  pattern[posZero] = '.'
	  }
  }
#+end_src
#+begin_export latex
Now that we have the pattern at hand, we perform the actual search. We
initialize some variables, compile the regular expression and find the
start position of the leftmost match in the query. We analyze the
result of the matching. Then we find the end coordinate and project
its coordinates onto the forward strand if it's been found on the
reverse strand. Finally, we populate the \texttt{reg} struct and
append it to the output slice using the \texttt{Mutex}. If the user
has opted to print actual match sequences, we do it now.
#+end_export
#+begin_src go <<Perform the matching>>=
  for _, qseq := range query {
	  qseqData := qseq.Data()
	  strandLen := len(qseqData) / 2
	  var regStart int

	  re := regexp.MustCompile(string(pattern))
	  match := re.FindIndex(qseqData)

	  //<<Match or mismatch?>>

	  regEnd := regStart + refseqLen
	  isReverse := false
	  if regStart > strandLen {
		  //<<Project the match onto the forward strand>>
	  }
	  //<<Populate the \texttt{region} struct>>
	  if *optS {
		  //<<Print the match sequence>>
	  }
	  mu.Lock()
	  regions = append(regions, reg)
	  mu.Unlock()
  }
#+end_src
#+begin_export latex
If a match has been found, we use its index as the start coordinate of
the region in the query. If there's no match, we proceed with the next
sequence of the query.
#+end_export
#+begin_src go <<Match or mismatch?>>=
  if match != nil {
	  regStart = match[0]
  } else {
	  continue
  }
#+end_src
#+begin_export latex
To project the match onto the forward strand, we swap its start and
its end and subtract it from the total length of both strands
(including the separator). Then we calculate the new end of the
region and toggle the \texttt{isReverse} indicator.
#+end_export
#+begin_src go <<Project the match onto the forward strand>>=
  regStart = len(qseqData) - regEnd
  regEnd = regStart + refseqLen
  isReverse = true
#+end_src
#+begin_export latex
We fill the fields of the resulting \texttt{region} struct.
#+end_export
#+begin_src go <<Populate the \texttt{region} struct>>=
  reg.rh = coordinateFields
  reg.rs = refStart
  reg.re = refEnd
  reg.qh = qseq.Header()
  reg.qs = regStart
  reg.qe = regEnd
  reg.onReverseStrand = isReverse
#+end_src
#+begin_export latex
We build a header and data for the output sequence corresponding to
the match region of the current query. Once we're done, we construct
and print the sequence.
#+end_export
#+begin_src go <<Print the match sequence>>=
  //<<Build the output header>>
  //<<Build the output data>>
  outSeq := fasta.NewSequence(outHeader, outData)
  fmt.Fprintf(os.Stdout, "%s\n", outSeq)
#+end_src
#+begin_export latex
We identify the strand and include the following in the output's
header: the first field of original reference header, name of the
query and the position of the region on the query, and the strand
name. We add one to the query starts to have them 1-based.
#+end_export
#+begin_src go <<Build the output header>>=
  //<<Set the \texttt{strand} value>>
  outHeader := fmt.Sprintf("%s_%s_(%d..%d)_%s",
	  reg.rh, reg.qh, reg.qs + 1, reg.qe,
	  strand)
#+end_src
#+begin_export latex
The \texttt{strand} variable keeps either "forward" or "reverese".
#+end_export
#+begin_src go <<Set the \texttt{strand} value>>=
  strand := "forward"
  if reg.onReverseStrand {
	  strand = "reverse"
  }
#+end_src
#+begin_export latex
To extract the relevant query sequence, we have to find the
corresponding contig first. We find it by its name and then use the
coordinates to extract a piece of its data.
#+end_export
#+begin_src go <<Build the output data>>=
  var queryContig *fasta.Sequence

  for _, seq := range query {
	  if seq.Header() == reg.qh {
		  queryContig = seq
	  }
  }

  outData := queryContig.Data()[reg.qs:reg.qe]
#+end_src
#+begin_export latex
We turn to making an output table of match coordinates.  We sort the
regions before printing, then we set the formatting for the header and
rows the table of the coordinates.
#+end_export
#+begin_src go <<Print match coordinates>>=
  //<<Sort the regions>>

  tableHeader := "# refName\trefStart\trefEnd\t" +
	    "queryName\tqueryStart\tqueryEnd\tstrand\n"
  tableFields := "%s\t%s\t%s\t%s\t%d\t%d\t%s\n"

  //<<Print the table of coordinates>>
#+end_src
#+begin_export latex
We sort the regions by reference contigs' names, query sequence's
name, and region start coordinates using the \texttt{sort.Slice}
function.
#+end_export
#+begin_src go <<Sort the regions>>=
  sort.Slice(regions, func(i, j int) bool {
	  if regions[i].rh != regions[j].rh {
		  return regions[i].rh < regions[j].rh
	  }
	  if regions[i].qh != regions[j].qh {
		  return regions[i].qh < regions[j].qh
	  }
	  return regions[i].rs < regions[j].rs
  })
#+end_src
#+begin_export latex
We import \texttt{sort}.
#+end_export
#+begin_src go <<Imports>>=
  "sort"
#+end_src

#+begin_export latex
We print the table's header, then we iterate over regions to print
their fields as the rows.  We add one to the start coordinates to have
them 1-based. Once we have finished, we close the file.
#+end_export
#+begin_src go <<Print the table of coordinates>>=
  fmt.Fprintf(os.Stdout, tableHeader)
  for _, reg := range regions {
	  //<<Set the \texttt{strand} value>>
	  fmt.Fprintf(os.Stdout, tableFields,
		  reg.rh, reg.rs, reg.re,
		  reg.qh, reg.qs + 1, reg.qe,
		  strand)
  }
#+end_src

#+begin_export latex
We initialize a \texttt{tabwriter}, print the table's header, then we
iterate over the regions and print them as rows of the table.
#+end_export
#+begin_src go <<Print coordinates>>=


  if *optO != "" {
	  //<<Print the output table to a file>>
  } else {
	  //<<Print the output table using a tabwriter>>
  }

#+end_src
#+begin_export latex
We create a tabwriter, print the table's header and fields.  We add
one to the start coordinates to have them 1-based. The writer is
getting flushed in the end.
#+end_export
#+begin_src go <<Print the output table using a tabwriter>>=
  writer := tabwriter.NewWriter(outputFile, 0, 0, 1, ' ', 0)
  fmt.Fprintf(writer, tableHeader)
  f
